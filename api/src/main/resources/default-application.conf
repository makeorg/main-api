akka {

  actor {

    debug {
      lifecycle = off
      log-sent-messages = off
    }

    provider = "akka.cluster.ClusterActorRefProvider"

    kryo {
      type = "graph"
      idstrategy = "default"
      post-serialization-transformations = "lz4"
      implicit-registration-logging = true
    }

    serializers {
      make-serializer = "org.make.api.technical.MakeEventSerializer"
      kryo-serializer = "com.romix.akka.serialization.kryo.KryoSerializer"
    }
    serialization-bindings {
      "org.make.core.MakeSerializable" = make-serializer
      "java.io.Serializable" = kryo-serializer
    }
  }

  cluster {
    role {
      seed {
        min-nr-of-members = 1
      }
      worker {
        min-nr-of-members = 1
      }
    }
    roles = ["seed", "worker"]

    run-coordinated-shutdown-when-down = true

    seed-nodes = []

    sharding {
      guardian-name = sharding
      remember-entities = false
      state-store-mode = ddata
      role = "worker"
    }
  }

  extensions = [de.heikoseeberger.constructr.ConstructrExtension, com.romix.akka.serialization.kryo.KryoSerializationExtension]

  http.client.connecting-timeout = "2 seconds"
  http.client.parsing.max-response-reason-length = 128

  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = "DEBUG"
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  persistence {
    journal {
      plugin = "make-api.event-sourcing.technical.read-journal"
    }
    snapshot-store {
      plugin = "make-api.event-sourcing.technical.snapshot-store"
    }
    role = "worker"
  }

  remote {
    artery {
      enabled = on
      transport = tcp
      canonical.hostname = "localhost"
      canonical.hostname = ${?HOSTNAME}
      canonical.hostname = ${?TCP_HOST}
      canonical.port = 2551
      canonical.port = ${?TCP_PORT}
      advanced.maximum-frame-size = 524288
    }
    log-remote-lifecycle-events = off
  }
}

constructr {
  coordination {
    nodes = ${make-api.zookeeper.url}

    zookeeper.rootpath = "/make-api"
  }

  coordination-timeout = "3 seconds"
  join-timeout = "15 seconds"
  max-nr-of-seed-nodes = -1
  refresh-interval = "10 seconds"
  nr-of-retries = 2
  retry-delay = "2 seconds"
  ttl-factor = 3.1
}

kamon {

  akka.ask-pattern-timeout-warning = "lightweight"

  akka-http.name-generator = "org.make.api.technical.MakeOperationNameGenerator"

  prometheus {
    embedded-server {
      # Hostname and port used by the embedded web server to publish the scraping enpoint.
      hostname = "0.0.0.0"
      hostname = ${?HTTP_HOST}
      port = 4000
      port = ${?MONITORING_PORT}
    }
  }

  system-metrics {
    host.enabled = false
  }

  cluster-sharding {
    regions = [
      "proposal",
      "user-history",
      "session-history"
    ],
    refresh-interval = "20 seconds"
    stats-timeout = "5 seconds"
  }

  subscriptions {
    akka-http-server = [ "**" ]
  }
  # What should be recorder
  util {
    filters {
      "akka.tracked-actor" {
        includes = ["*/user/make-api/**"]
        excludes = ["*/system/**", "*/user/make-api/health-checks/**"]
      }
      "akka.tracked-dispatcher" {
        includes = [
          "*/akka.actor.default-dispatcher",
          "*/make-api.kafka.dispatcher",
          "*/make-api.elasticSearch.dispatcher",
          "*/make-api.semantic.dispatcher",
          "*/make-api.mail-jet.dispatcher"
        ]
      }
      "akka.tracked-router" {
        includes = [ "**" ]
      }

      system-metric {
        includes = [ "**" ]
      }

      trace {
        includes = ["**"]
        excludes = []
      }
    }
  }
}

make-api {

  authentication {
    default-client-id = "0cdd82cb-5cc0-4875-bb54-5c3709449429"
    default-client-id = ${?DEFAULT_CLIENT_ID}
    default-client-secret = "f4f7076e-6337-41d5-b000-3726ead0ae41"
    default-client-secret = ${?DEFAULT_CLIENT_SECRET}
  }

  authorized-cors-uri: ["http://localhost:9009", "http://localhost:4242", "http://localhost:3000"]
  authorized-cors-uri: ${?AUTHORIZED_CORS_URI}

  cookie-visitor {
    is-secure = false
    is-secure = ${?VISITOR_COOKIE_IS_SECURE}
    domain = "localhost"
  }

  cookie-session {
    lifetime = "20 minutes"
    lifetime = ${?SESSION_COOKIE_LIFETIME}
    is-secure = false
    is-secure = ${?SESSION_COOKIE_IS_SECURE}
    domain = "localhost"
  }

  database {
    jdbc-url = "jdbc:postgresql://localhost:26257/makeapi"
    jdbc-url = ${?JDBC_URL}
    user = "root"
    user = ${?DB_USER}
    password = ""
    password = ${?DB_PASSWORD}
    pools {
      read {
        max-total = 30
        initial-size = 10
        max-idle = 10
      }
      write {
        max-total = 80
        initial-size = 10
        max-idle = 10
      }
    }
    migration {
      init-schema = true
      baseline-version = "1.1"
    }
  }

  default-admin {
    first-name: "admin"
    email: "admin@make.org"
    password: "admin"
  }

  dev {
    # This environment is dynamic (dev + review app),
    # which means data are wiped regularly and we need to insert fixtures
    environment-type = "dynamic"
  }

  duplicate-detector {
    max-results = 25
    max-results = ${?DUPLICATE_DETECTOR_MAX_RESULTS}
  }

  elasticSearch {
    dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"
      thread-pool-executor {
        fixed-pool-size = 16
      }
      throughput = 1
    }
    connection-string = "localhost:9200"
    connection-string = ${?ES_URL}
    index-name = "make"
    index-name = ${?ES_INDEX_NAME}
    idea-alias-name = "idea"
    idea-alias-name = ${?ES_IDEA_ALIAS_NAME}
    organisation-alias-name = "organisation"
    organisation-alias-name = ${?ES_ORGANISATION_ALIAS_NAME}
    proposal-alias-name = "proposal"
    proposal-alias-name = ${?ES_PROPOSAL_ALIAS_NAME}
    operation-of-question-alias-name = "operation-of-question"
    operation-of-question-alias-name = ${?ES_OPERATION_OF_QUESTION_ALIAS_NAME}
    buffer-size = 100
    buffer-size = ${?ES_BUFFER_SIZE}
    bulk-size = 100
    bulk-size = ${?ES_BULK_SIZE}
  }

  environment = "dev"

  event-sourcing {

    proposals {
      read-journal = ${cassandra-journal}
      read-journal {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        query-plugin = "make-api.event-sourcing.proposals.query-journal"

        table = "proposal_events"
        metadata-table = "proposal_events_metadata"
        config-table = "proposal_events_config"
        events-by-tag.table = "proposal_tag_views"
      }

      snapshot-store = ${cassandra-snapshot-store}
      snapshot-store {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        table = "proposal_snapshots"
        metadata-table = "proposal_snapshots_metadata"
        config-table = "proposals_snapshot_config"
      }

      query-journal = ${cassandra-query-journal}
      query-journal {
        write-plugin = "make-api.event-sourcing.proposals.read-journal"
      }
    }

    sequences {
      read-journal = ${cassandra-journal}
      read-journal {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        query-plugin = "make-api.event-sourcing.sequences.query-journal"

        table = "sequence_events"
        metadata-table = "sequence_events_metadata"
        config-table = "sequence_events_config"
        events-by-tag.table = "sequence_tag_views"
      }

      snapshot-store = ${cassandra-snapshot-store}
      snapshot-store {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        table = "sequence_snapshots"
        metadata-table = "sequence_snapshots_metadata"
        config-table = "sequence_snapshot_config"
      }

      query-journal = ${cassandra-query-journal}
      query-journal {
        write-plugin = "make-api.event-sourcing.sequences.read-journal"
      }
    }

    sessions {
      read-journal = ${cassandra-journal}
      read-journal {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        query-plugin = "make-api.event-sourcing.sessions.query-journal"

        table = "session_events"
        metadata-table = "session_events_metadata"
        config-table = "session_events_config"
        events-by-tag.table = "session_tag_views"
      }

      snapshot-store = ${cassandra-snapshot-store}
      snapshot-store {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        table = "session_snapshots"
        metadata-table = "session_snapshots_metadata"
        config-table = "session_snapshot_config"
      }

      query-journal = ${cassandra-query-journal}
      query-journal {
        write-plugin = "make-api.event-sourcing.sessions.read-journal"
      }
    }

    users {
      read-journal = ${cassandra-journal}
      read-journal {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        query-plugin = "make-api.event-sourcing.users.query-journal"

        table = "user_events"
        metadata-table = "user_events_metadata"
        config-table = "user_events_config"
        events-by-tag.table = "user_tag_views"
      }

      snapshot-store = ${cassandra-snapshot-store}
      snapshot-store {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        table = "user_snapshots"
        metadata-table = "user_snapshots_metadata"
        config-table = "user_snapshot_config"
      }

      query-journal = ${cassandra-query-journal}
      query-journal {
        write-plugin = "make-api.event-sourcing.users.read-journal"
      }
    }

    technical {
      read-journal = ${cassandra-journal}
      read-journal {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        query-plugin = "make-api.event-sourcing.technical.query-journal"

        table = "technical_events"
        metadata-table = "technical_events_metadata"
        config-table = "technical_events_config"
        events-by-tag.table = "technical_tag_views"
      }

      snapshot-store = ${cassandra-snapshot-store}
      snapshot-store {
        keyspace = "makeapi"
        keyspace = ${?CASSANDRA_KEYSPACE}
        table = "technical_snapshots"
        metadata-table = "technical_snapshots_metadata"
        config-table = "technical_snapshot_config"
      }

      query-journal = ${cassandra-query-journal}
      query-journal {
        write-plugin = "make-api.event-sourcing.technical.read-journal"
      }
    }
  }

  http {
    host = "0.0.0.0"
    host = ${?HTTP_HOST}
    port = 9000
    port = ${?HTTP_PORT}
    ssl = false
    ssl = ${?SSL}
  }

  kafka {
    dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"
      thread-pool-executor {
        fixed-pool-size = 32
      }
      throughput = 1
    }

    connection-string = "localhost:9092"
    connection-string = ${?KAFKA_URI}
    poll-timeout = 10000
    schema-registry = "http://localhost:18081"
    schema-registry = ${?AVRO_REGISTRY_URL}
    topics {
      emails = "emails-v2"
      emails = ${?KAFKA_EMAIL_TOPIC}
      mailjet-events = "mailjet-v2"
      mailjet-events = ${?KAFKA_MAILJET_EVENT_TOPIC}
      proposals = "proposals-v2"
      proposals = ${?KAFKA_PROPOSALS_TOPIC}
      users = "users-v2"
      users = ${?KAFKA_USER_TOPIC}
      // Topic was changed when data structure changed.
      duplicates-predicted = "duplicates-v2"
      duplicates-predicted = ${?KAFKA_DUPLICATE_PREDICTED_TOPIC}
      // Topic was changed when data structure changed.
      tracking-events = "tracking-v2"
      tracking-events = ${?KAFKA_TRACKING_EVENTS_TOPIC}
      ideas = "ideas-v2"
      ideas = ${?KAFKA_IDEAS_TOPIC}
      predictions = "predictions"
      predictions = ${?KAFKA_PREDICTIONS_TOPIC}
    }
  }

  mail-jet {
    dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"
      thread-pool-executor {
        fixed-pool-size = 32
      }
      throughput = 1
    }
    http-buffer-size = 100
    url = "https://api.mailjet.com"
    api-key = "transactional-emails-api-key"
    api-key = ${?MAILJET_API_KEY}
    secret-key = "transactional-emails-secret-key"
    secret-key = ${?MAILJET_SECRET_KEY}
    campaign-api-key = "contact-list-api-key"
    campaign-api-key = ${?CAMPAIGN_MAILJET_API_KEY}
    campaign-secret-key = "contact-list-secret-key"
    campaign-secret-key = ${?CAMPAIGN_MAILJET_SECRET_KEY}
    basic-auth-login = "make-mailjet"
    basic-auth-login = ${?MAILJET_AUTH_LOGIN}
    basic-auth-password = "ZUtV95wY56YziEr5"
    basic-auth-password = ${?MAILJET_AUTH_PASSWORD}

    user-list {
      hard-bounce-list-id = "2412499"
      hard-bounce-list-id = ${?MAILJET_HARD_BOUNCE_LIST_ID}
      unsubscribe-list-id = "2412500"
      unsubscribe-list-id = ${?MAILJET_UNSUB_LIST_ID}
      opt-in-list-id = "2412498"
      opt-in-list-id = ${?MAILJET_OPTIN_LIST_ID}
      batch-size = 1000
      batch-size = ${?MAILJET_USER_LIST_BATCH_SIZE}
    }

    templates {
      from = "emailing@make.org"
      from-name = "make.org"
      front-url = "http://localhost:9009"
      front-main-url = "http://localhost:9009"
    }
  }

  newsletter-url = "https://webflow.com/api/v1/form/59833d390a24e50001b873d8"
  newsletter-url = ${?NEWSLETTER_URL}

  oauth {
    access-token-lifetime = 1800
    access-token-lifetime = ${?ACCESS_TOKEN_LIFETIME}
    refresh-token-lifetime = 14400
    refresh-token-lifetime = ${?REFRESH_TOKEN_LIFETIME}
  }

  passivate-timeout = "2 minutes"
  max-user-history-events = 10000

  secrets-configuration-path = "/etc/make/make-api.conf"

  security {
    secure-hash-salt = "jxu-qdimuh-yi-42"
    secure-hash-salt = ${?SECURE_HASH_SALT}
    secure-vote-salt = "d3f4u17v0735417"
    secure-vote-salt = ${?SECURE_VOTE_SALT}
  }

  selection-algorithm {
    new-proposals-ratio = 0.0
    new-proposals-vote-threshold = 100
    tested-proposals-engagement-threshold = 0.80
    bandit-enabled = false
    bandit-min-count = 3
    bandit-proposals-ratio = 0
  }

  semantic {
    dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"
      thread-pool-executor {
        fixed-pool-size = 16
      }
      throughput = 1
    }
    http-buffer-size = 100
    url = "http://localhost:9001"
    url = ${?SEMANTIC_URL}
  }

  storage {
    bucket-name = "assets"
    bucket-name = ${?STORAGE_BUCKET_NAME}
    base-url = "http://localhost:48080/v1.0/AUTH_test/assets"
    base-url = ${?CDN_BASE_URL}
  }

  zookeeper {
    url = "localhost:12181"
    url = ${?ZOOKEEPER_URL}
  }
  
}

make-openstack {
  authentication {
    keystone-version = "keystone-V1"
    base-url = "http://localhost:48080/auth/v1.0"
    tenant-name = "test"
    username = "tester"
    password = "testing"
    region = ""
  }

  storage {
    init-containers = [${make-api.storage.bucket-name}]
  }
}